#!/usr/bin/env python3
"""
codex-ns: CodexCLI + NeuralSync Integration Wrapper
Auto-launch, shared memory, and inter-agent communication
"""

import asyncio
import os
import sys
import json
import time
import subprocess
import signal
import logging
from pathlib import Path
from typing import Optional, Dict, Any, List
import tempfile
import shutil

# Add NeuralSync to path
sys.path.insert(0, str(Path(__file__).parent.parent))

from neuralsync.daemon_manager import ensure_neuralsync_running, get_daemon_manager
from neuralsync.ultra_comm import CliCommunicator
from neuralsync.config import load_config

# Configure logging
logging.basicConfig(
    level=logging.WARNING,
    format='%(asctime)s - %(name)s - %(levelname)s - %(message)s'
)
logger = logging.getLogger(__name__)


class CodexNSWrapper:
    """Enhanced CodexCLI wrapper with NeuralSync integration"""
    
    def __init__(self):
        self.cli_name = "codex-cli"
        self.capabilities = {
            "code-completion", "generation", "optimization", "translation",
            "code-search", "pattern-recognition", "api-integration"
        }
        
        self.ns_config = load_config()
        self.communicator: Optional[CliCommunicator] = None
        self.temp_files = []
        self._last_status_len = 0

    def _status(self, msg: str, end: bool = False):
        try:
            line = f"\r{msg}"
            pad = max(0, self._last_status_len - len(msg))
            sys.stderr.write(line + (" " * pad))
            sys.stderr.flush()
            self._last_status_len = len(msg)
            if end:
                sys.stderr.write("\n")
                sys.stderr.flush()
                self._last_status_len = 0
        except Exception:
            # Fallback to simple print if terminal update fails
            print(msg, file=sys.stderr)
        
    async def ensure_services_running(self) -> bool:
        """Ensure NeuralSync services are running"""
        try:
            # Fast-path: probe HTTP health first to avoid unnecessary restarts
            try:
                import requests
                resp = requests.get(
                    f"http://{self.ns_config.bind_host}:{self.ns_config.bind_port}/health",
                    timeout=2
                )
                if resp.status_code == 200:
                    return True
            except Exception:
                pass
            # Fallback to daemon-managed ensure
            return await ensure_neuralsync_running()
        except Exception as e:
            logger.error(f"Failed to ensure NeuralSync services: {e}")
            return False
            
    async def setup_communication(self) -> bool:
        """Setup inter-CLI communication"""
        try:
            self.communicator = CliCommunicator(self.cli_name, self.capabilities)
            
            # Register message handlers for inter-agent communication
            self.communicator.register_message_handler("generate_code", self._handle_generation_request)
            self.communicator.register_message_handler("complete_code", self._handle_completion_request)
            self.communicator.register_message_handler("optimize_code", self._handle_optimization_request)
            self.communicator.register_message_handler("translate_code", self._handle_translation_request)
            self.communicator.register_message_handler("search_patterns", self._handle_search_request)
            self.communicator.register_message_handler("spawn_agent", self._handle_spawn_request)
            self.communicator.register_message_handler("sync_memory", self._handle_memory_sync)
            
            await self.communicator.connect()
            logger.info("Codex-NS communication system initialized")
            return True
            
        except Exception as e:
            logger.error(f"Failed to setup communication: {e}")
            return False
            
    async def _handle_generation_request(self, data: Dict[str, Any]) -> Dict[str, Any]:
        """Handle code generation request from other agents"""
        try:
            prompt = data.get('prompt', '')
            language = data.get('language', 'python')
            context = data.get('context', '')
            
            # Store generation request
            await self._remember_interaction("code_generation", f"Generating {language} code: {prompt}", context)
            
            # Create temp file for output
            with tempfile.NamedTemporaryFile(mode='w', suffix=f'.{language}', delete=False) as f:
                temp_file = f.name
                self.temp_files.append(temp_file)
            
            # Generate code using codexcli (simplified - would use actual CLI)
            generation_context = f"""Generate {language} code for: {prompt}

Context: {context}

Requirements:
- Clean, readable code
- Proper error handling
- Documentation/comments
- Follow best practices for {language}
"""
            
            return {
                "status": "generated",
                "prompt": prompt,
                "language": language,
                "output_file": temp_file,
                "context": generation_context,
                "agent": "codex-cli",
                "timestamp": time.time()
            }
            
        except Exception as e:
            logger.error(f"Generation request error: {e}")
            return {"status": "error", "message": str(e)}
            
    async def _handle_completion_request(self, data: Dict[str, Any]) -> Dict[str, Any]:
        """Handle code completion request"""
        try:
            partial_code = data.get('code', '')
            cursor_position = data.get('cursor', len(partial_code))
            language = data.get('language', 'python')
            
            # Store completion context
            await self._remember_interaction("code_completion", 
                                           f"Code completion for {language}", 
                                           partial_code[:200])
            
            # Generate completions (simplified)
            completion_suggestions = [
                {"text": "# AI-generated completion suggestion", "score": 0.9},
                {"text": "# Additional completion option", "score": 0.7}
            ]
            
            return {
                "status": "completed",
                "language": language,
                "suggestions": completion_suggestions,
                "cursor_position": cursor_position,
                "agent": "codex-cli",
                "timestamp": time.time()
            }
            
        except Exception as e:
            logger.error(f"Completion request error: {e}")
            return {"status": "error", "message": str(e)}
            
    async def _handle_optimization_request(self, data: Dict[str, Any]) -> Dict[str, Any]:
        """Handle code optimization request"""
        try:
            code = data.get('code', '')
            optimization_type = data.get('type', 'performance')
            language = data.get('language', 'python')
            
            await self._remember_interaction("code_optimization", 
                                           f"Optimizing {language} code ({optimization_type})", 
                                           code[:200])
            
            # Create optimized version (placeholder)
            with tempfile.NamedTemporaryFile(mode='w', suffix=f'.{language}', delete=False) as f:
                f.write(f"# Optimized {language} code ({optimization_type})\n{code}")
                temp_file = f.name
                self.temp_files.append(temp_file)
            
            return {
                "status": "optimized",
                "optimization_type": optimization_type,
                "language": language,
                "output_file": temp_file,
                "improvements": ["Performance enhanced", "Memory usage reduced"],
                "agent": "codex-cli",
                "timestamp": time.time()
            }
            
        except Exception as e:
            return {"status": "error", "message": str(e)}
            
    async def _handle_translation_request(self, data: Dict[str, Any]) -> Dict[str, Any]:
        """Handle code translation between languages"""
        try:
            code = data.get('code', '')
            from_lang = data.get('from_language', 'python')
            to_lang = data.get('to_language', 'javascript')
            
            await self._remember_interaction("code_translation", 
                                           f"Translating code from {from_lang} to {to_lang}", 
                                           code[:200])
            
            # Create translated version
            with tempfile.NamedTemporaryFile(mode='w', suffix=f'.{to_lang}', delete=False) as f:
                f.write(f"// Translated from {from_lang} to {to_lang}\n{code}")
                temp_file = f.name
                self.temp_files.append(temp_file)
                
            return {
                "status": "translated",
                "from_language": from_lang,
                "to_language": to_lang,
                "output_file": temp_file,
                "agent": "codex-cli",
                "timestamp": time.time()
            }
            
        except Exception as e:
            return {"status": "error", "message": str(e)}
            
    async def _handle_search_request(self, data: Dict[str, Any]) -> Dict[str, Any]:
        """Handle code pattern search request"""
        try:
            pattern = data.get('pattern', '')
            search_type = data.get('type', 'function')
            language = data.get('language', 'any')
            
            await self._remember_interaction("code_search", 
                                           f"Searching for {search_type} patterns: {pattern}", 
                                           f"Language: {language}")
            
            # Mock search results
            results = [
                {"file": "example.py", "line": 42, "match": pattern, "context": "def example():"},
                {"file": "utils.js", "line": 15, "match": pattern, "context": "function helper() {"}
            ]
            
            return {
                "status": "searched",
                "pattern": pattern,
                "search_type": search_type,
                "language": language,
                "results": results,
                "agent": "codex-cli",
                "timestamp": time.time()
            }
            
        except Exception as e:
            return {"status": "error", "message": str(e)}
            
    async def _handle_spawn_request(self, data: Dict[str, Any]) -> Dict[str, Any]:
        """Handle request to spawn another agent"""
        try:
            agent_type = data.get('agent', '')
            task = data.get('task', '')
            context = data.get('context', {})
            
            agent_commands = {
                'claude': 'claude-ns',
                'gemini': 'gemini-ns',
                'codex': 'codex-ns'
            }
            
            if agent_type not in agent_commands:
                return {"status": "error", "message": f"Unknown agent type: {agent_type}"}
                
            cmd = [agent_commands[agent_type], '--task', json.dumps({"task": task, "context": context})]
            
            try:
                process = subprocess.Popen(
                    cmd,
                    stdout=subprocess.PIPE,
                    stderr=subprocess.PIPE,
                    text=True
                )
                
                await self._remember_interaction("agent_spawn", f"Spawned {agent_type} agent", task)
                
                return {
                    "status": "spawned",
                    "agent": agent_type,
                    "pid": process.pid,
                    "task": task,
                    "timestamp": time.time()
                }
                
            except Exception as e:
                return {"status": "error", "message": f"Failed to spawn {agent_type}: {e}"}
                
        except Exception as e:
            return {"status": "error", "message": str(e)}
            
    async def _handle_memory_sync(self, data: Dict[str, Any]) -> Dict[str, Any]:
        """Handle memory synchronization between agents"""
        try:
            sync_type = data.get('type', 'pull')
            query = data.get('query', '')
            
            if sync_type == 'pull':
                await self._remember_interaction("memory_sync", f"Memory pull request: {query}", "")
                return {
                    "status": "synced",
                    "type": "pull",
                    "query": query,
                    "timestamp": time.time()
                }
                
            elif sync_type == 'push':
                memory_data = data.get('memory', {})
                await self._remember_interaction("memory_push", "Received memory from another agent", str(memory_data)[:200])
                return {
                    "status": "synced", 
                    "type": "push",
                    "timestamp": time.time()
                }
                
        except Exception as e:
            return {"status": "error", "message": str(e)}
            
    async def _remember_interaction(self, kind: str, text: str, context: str):
        """Store interaction in NeuralSync memory"""
        try:
            import requests
            
            headers = {}
            if self.ns_config.token:
                headers["Authorization"] = f"Bearer {self.ns_config.token}"
                
            payload = {
                "text": text,
                "kind": kind,
                "scope": "inter-agent",
                "tool": self.cli_name,
                "tags": ["auto-generated", "inter-agent", "codex"],
                "confidence": 0.9,
                "source": "codex-ns",
                "meta": {"context": context, "timestamp": time.time()}
            }
            
            requests.post(
                f"http://{self.ns_config.bind_host}:{self.ns_config.bind_port}/remember",
                headers=headers,
                json=payload,
                timeout=5
            )
            
        except Exception as e:
            logger.debug(f"Failed to store memory: {e}")
            
    async def get_shared_context(self) -> str:
        """Get shared persona and memory context from NeuralSync"""
        try:
            import requests
            import sqlite3
            from pathlib import Path
            
            headers = {}
            if self.ns_config.token:
                headers["Authorization"] = f"Bearer {self.ns_config.token}"
            
            # Get persona
            persona = ""
            try:
                persona_response = requests.get(
                    f"http://{self.ns_config.bind_host}:{self.ns_config.bind_port}/persona",
                    headers=headers,
                    timeout=5
                )
                if persona_response.status_code == 200:
                    persona = persona_response.json().get("text", "")
            except Exception:
                # HTTP persona fetch failed; will fall back below
                pass
            
            # Get relevant memories for code generation context
            memory_context = ""
            try:
                recall_response = requests.post(
                    f"http://{self.ns_config.bind_host}:{self.ns_config.bind_port}/recall",
                    headers=headers,
                    json={
                        "query": "code generation completion optimization",
                        "top_k": 8,
                        "scope": "any", 
                        "tool": None
                    },
                    timeout=10
                )
                if recall_response.status_code == 200:
                    recall_data = recall_response.json()
                    memory_context = recall_data.get("preamble", "")
            except Exception:
                # HTTP recall failed; will fall back to local DB
                pass

            # Local DB fallback if HTTP failed or returned empty
            if not persona or not memory_context:
                try:
                    db_path = Path.home()/'.neuralsync'/'memory.db'
                    if db_path.exists():
                        con = sqlite3.connect(str(db_path))
                        con.row_factory = sqlite3.Row
                        cur = con.cursor()
                        # Pull the most recent, high-confidence items across tools
                        cur.execute(
                            """
                            SELECT kind, text, tool, source, created_at
                            FROM items
                            WHERE tombstone = 0 AND (confidence IS NULL OR confidence >= 0.6)
                            ORDER BY created_at DESC
                            LIMIT 12
                            """
                        )
                        rows = cur.fetchall()
                        if rows and not memory_context:
                            excerpts = []
                            for r in rows:
                                t = (r['text'] or '').strip()
                                if not t:
                                    continue
                                # Keep short excerpts to avoid flooding
                                excerpts.append(f"- [{r['tool'] or r['source']}] {t[:200]}")
                            if excerpts:
                                memory_context = "Recent shared context:\n" + "\n".join(excerpts)
                        con.close()
                except Exception:
                    # Silent fallback
                    pass
            
            # Combine context
            context_parts = []
            if persona:
                context_parts.append(f"Persona: {persona}")
            if memory_context:
                context_parts.append(memory_context)
                
            return "\n\n".join(context_parts) + ("\n\n" if context_parts else "")
            
        except Exception as e:
            logger.debug(f"Failed to get shared context: {e}")
            return ""
            
    async def run_codexcli(self, args: List[str]) -> int:
        """Run CodexCLI with NeuralSync context injection"""
        try:
            # Get shared context
            shared_context = await self.get_shared_context()
            
            # Find codexcli executable
            codex_cmd = shutil.which('codexcli')
            if not codex_cmd:
                print("ERROR: codexcli not found in PATH", file=sys.stderr)
                print("Please install CodexCLI first", file=sys.stderr)
                return 1
                
            # Prepare environment
            env = os.environ.copy()
            env.update({
                'NS_HOST': self.ns_config.bind_host,
                'NS_PORT': str(self.ns_config.bind_port),
                'NS_TOKEN': self.ns_config.token,
                'NEURALSYNC_CONTEXT': shared_context,
                'CLI_WRAPPER': 'codex-ns'
            })
            
            # Handle stdin input or repair override
            repair_override = os.environ.get('NEURALSYNC_REPAIR_INPUT')
            if repair_override is not None or (not args or (len(args) == 1 and args[0] in ['-', '--stdin'])):
                input_data = repair_override if repair_override is not None else (sys.stdin.read() if not sys.stdin.isatty() else "")
                
                # Enhance input with context for better code generation
                enhanced_input = f"""{shared_context}

Code Generation Request:
{input_data}

Please generate clean, well-documented code with proper error handling."""

                process = subprocess.Popen(
                    [codex_cmd],
                    stdin=subprocess.PIPE,
                    stdout=sys.stdout,
                    stderr=sys.stderr,
                    env=env,
                    text=True
                )
                
                process.communicate(input=enhanced_input)
                return process.returncode
                
            else:
                # Run with args and enhanced environment
                process = subprocess.run(
                    [codex_cmd] + args,
                    env=env
                )
                return process.returncode
                
        except Exception as e:
            logger.error(f"Failed to run codexcli: {e}")
            print(f"ERROR: {e}", file=sys.stderr)
            return 1
            
    def cleanup(self):
        """Cleanup temporary files"""
        for temp_file in self.temp_files:
            try:
                os.unlink(temp_file)
            except:
                pass
                
    async def run(self, args: List[str]) -> int:
        """Main run method"""
        try:
            repair_msg: str = ""
            # Handle special arguments
            if len(args) > 0:
                if args[0] == '--neuralsync-status':
                    manager = get_daemon_manager()
                    status = manager.get_system_info()
                    print(json.dumps(status, indent=2))
                    return 0
                    
                elif args[0] == '--spawn-agent':
                    if len(args) < 3:
                        print("Usage: codex-ns --spawn-agent <agent_type> <task>", file=sys.stderr)
                        return 1
                        
                    agent_type = args[1]
                    task = ' '.join(args[2:])
                    
                    if self.communicator:
                        result = await self._handle_spawn_request({
                            'agent': agent_type,
                            'task': task,
                            'context': {}
                        })
                        print(json.dumps(result, indent=2))
                        return 0 if result['status'] != 'error' else 1
                        
                elif args[0] == '--task':
                    # Handle spawned task
                    if len(args) > 1:
                        try:
                            task_data = json.loads(args[1])
                            task = task_data.get('task', '')
                            context = task_data.get('context', {})
                            
                            await self._remember_interaction("spawned_task", f"Processing spawned task: {task}", str(context))
                            
                            # Create task input for codexcli
                            task_input = f"""Task: {task}
Context: {json.dumps(context, indent=2)}

Please generate appropriate code for this task."""
                            
                            return await self.run_codexcli([])
                            
                        except json.JSONDecodeError:
                            print("ERROR: Invalid task JSON", file=sys.stderr)
                            return 1
            
            # Ensure NeuralSync services are running (single-line status)
            self._status("NS: checking services…")
            services_ready = await self.ensure_services_running()
            if services_ready:
                self._status("NS: ready · linking comms…")
                ok = await self.setup_communication()
                if ok:
                    self._status("NS: ready", end=True)
                else:
                    self._status("NS: comms failed · self-repair…", end=True)
                    repair_msg = "NeuralSync communication setup failed. Please analyze and fix NeuralSync v2 server and wrappers so that /health, /persona, /recall work on 127.0.0.1:8373."
            else:
                self._status("NS: unavailable · self-repair…", end=True)
                repair_msg = "NeuralSync services unavailable. Please restore NeuralSync v2 so wrappers can fetch persona/recall."

            # If repair needed, inject a self-repair prompt for codexcli
            if repair_msg:
                os.environ['NEURALSYNC_REPAIR_INPUT'] = (
                    f"SYSTEM SELF-REPAIR MODE (macOS):\n"
                    f"Issue: {repair_msg}\n"
                    f"Constraints: minimal, focused patches; do not break APIs.\n"
                    f"Targets: ~/NeuralSync2/neuralsync (enhanced_server.py, storage.py, research_dedup.py, daemon_manager.py).\n"
                    f"Goals:\n- Ensure server binds to 127.0.0.1:8373 and exposes /persona,/remember,/recall.\n- Add SQLite busy_timeout and thread-safety.\n- Fix mmap resize safety.\n- Make heavy deps optional.\n- Restart server and verify /health.\n"
                    f"Deliver: file diffs and restart steps; then verify with curl.\n"
                )
                # Inform user briefly
                self._status("NS: self-repair initiated via codex", end=True)

            # Run codex CLI with NeuralSync integration or repair task
            rc = await self.run_codexcli(args)
            # Clear repair override to avoid leaking to child shells
            if 'NEURALSYNC_REPAIR_INPUT' in os.environ:
                os.environ.pop('NEURALSYNC_REPAIR_INPUT', None)
            return rc

            # Run codexcli with NeuralSync integration
            return await self.run_codexcli(args)
            
        finally:
            # Cleanup
            self.cleanup()
            if self.communicator:
                await self.communicator.disconnect()


async def main():
    """Main entry point"""
    wrapper = CodexNSWrapper()
    
    # Handle signals gracefully
    def signal_handler(sig, frame):
        asyncio.create_task(wrapper.communicator.disconnect() if wrapper.communicator else asyncio.sleep(0))
        sys.exit(0)
        
    signal.signal(signal.SIGINT, signal_handler)
    signal.signal(signal.SIGTERM, signal_handler)
    
    # Run wrapper
    try:
        return_code = await wrapper.run(sys.argv[1:])
        sys.exit(return_code)
    except KeyboardInterrupt:
        sys.exit(0)
    except Exception as e:
        logger.error(f"Codex-NS wrapper error: {e}")
        sys.exit(1)


if __name__ == "__main__":
    asyncio.run(main())
